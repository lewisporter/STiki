package db_client;

import core_objects.pair;
import core_objects.stiki_utils.SCORE_SYS;

import java.sql.CallableStatement;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Andrew G. West - qmanager_client.java - This class wraps all [queue_*]
 * stored procedures implemented by STiki, and provides single
 * methods to call them concurrently, where nedded. For example, choosing to
 * ignore an RID in one queue, should also set the ignore property in all
 * others. A similar semantic governs the reservation system.
 * This particular version is specific to CLIENT-side operation.
 */
public class qmanager_client {

	// **************************** PRIVATE FIELDS ***************************

	/**
	 * Persistent connection to the STiki server (limited permissions).
	 */
	private stiki_con_client con_client;

	/**
	 * SQL call fetching a reservation of edits from the "Cluebot-NG" queue.
	 */
	private CallableStatement cstmt_queue_fetch_cbng;

	/**
	 * SQL call fetching a reservation of edits from the "STiki" queue.
	 */
	private CallableStatement cstmt_queue_fetch_stiki;

	/**
	 * SQL call fetching a reservation of edits from the "WikiTrust" queue.
	 */
	private CallableStatement cstmt_queue_fetch_wt;

	/**
	 * SQL call fetching a reservation of edits from the "Link Spam" queue.
	 */
	private CallableStatement cstmt_queue_fetch_spam;

	/**
	 * SQL call removing an edit from a shared revision queue.
	 */
	private CallableStatement cstmt_queue_delete;

	/**
	 * SQL call indicating a user wants to "ignore" classifying some edit.
	 */
	private CallableStatement cstmt_queue_ignore;

	/**
	 * SQL call to "resurrect" RIDs if INNOCENT->PASS reclassification is
	 * performed as a result of using the "back" button.
	 */
	private CallableStatement cstmt_queue_resurrect;

	/**
	 * SQL call releasing a reservation (e.g., on program exit).
	 */
	private CallableStatement cstmt_queue_wipe;


	// ***************************** CONSTRUCTORS ****************************

	/**
	 * Construct a "queue manager" for the client GUI.
	 *
	 * @param con Connection to STiki servers (limited privileges)
	 */
	public qmanager_client(stiki_con_client con_client) throws Exception {
		this.con_client = con_client;
		prep_statements();
	}


	// **************************** PUBLIC METHODS ***************************

	// Note: Of all the CLIENT-SIDE queue maintenance calls, ONLY the
	// "fetch" one requires that a specific queue be mentioned (so it
	// knows which ordering to use as the basis for the reservation).
	// However, even this call cascades to other queues (the RID is
	// marked as reserved in all queues).
	//
	// ALL other methods are applicable to ALL queues. A removal from
	// one queue is equivalent to a removal for all others. Despite
	// slightly variant backend processing times, this seems like a
	// reasonable semantic on the CLIENT-SIDE. Implementation of "all"
	// is handled by SQL in the stored procedures themselves.

	/**
	 * Get (and temporarily reserve) a set of edits to classify. As a side
	 * effect, a reservation of duration [RESERVATION_TTL_SECS] is placed
	 * on each RID returned by this method (in ALL queues). Users should
	 * not see revisions which they have previously ignored/passed.
	 *
	 * @param sys    Queue (table name) whose scoring should be basis for fetch
	 * @param user   Wiki-login or IP address of the STiki user, so that
	 *               they will not be queued edits which they have previously passed/ignored
	 * @param res_id A numerical identifier for the reservation, presumably
	 *               should be randomly generated by the client.
	 * @return A queue of edits. Each element in the array is a pair, whose
	 * first element is an RID in need of classification,and the second element
	 * is the P_ID (article) on which the edit resides.
	 */
	public synchronized Queue<pair<Long, Long>> queue_fetch(SCORE_SYS sys,
	                                                        String user, long res_id) throws Exception {

		String csv_queue = "";
		if (sys.equals(SCORE_SYS.CBNG)) {
			cstmt_queue_fetch_cbng.setString(1, user);
			cstmt_queue_fetch_cbng.setLong(2, res_id);
			cstmt_queue_fetch_cbng.execute();
			csv_queue = cstmt_queue_fetch_cbng.getString(3);
		} else if (sys.equals(SCORE_SYS.STIKI)) {
			cstmt_queue_fetch_stiki.setString(1, user);
			cstmt_queue_fetch_stiki.setLong(2, res_id);
			cstmt_queue_fetch_stiki.execute();
			csv_queue = cstmt_queue_fetch_stiki.getString(3);
		} else if (sys.equals(SCORE_SYS.WT)) {
			cstmt_queue_fetch_wt.setString(1, user);
			cstmt_queue_fetch_wt.setLong(2, res_id);
			cstmt_queue_fetch_wt.execute();
			csv_queue = cstmt_queue_fetch_wt.getString(3);
		} else if (sys.equals(SCORE_SYS.SPAM)) {
			cstmt_queue_fetch_spam.setString(1, user);
			cstmt_queue_fetch_spam.setLong(2, res_id);
			cstmt_queue_fetch_spam.execute();
			csv_queue = cstmt_queue_fetch_spam.getString(3);
		} // Make the stored procedure call (table specific), get output

		// Trim trailing comma, assume well-formedness of the
		// SQL output: {pid,rid,pid,rid....}
		csv_queue = csv_queue.substring(0, csv_queue.length() - 1);
		String[] csv_parts = csv_queue.split(",");
		Queue<pair<Long, Long>> queue = new LinkedList<pair<Long, Long>>();
		for (int i = 0; i < csv_parts.length; i += 2)
			queue.offer(new pair<Long, Long>(Long.parseLong(csv_parts[i]),
					Long.parseLong(csv_parts[i + 1])));
		return (queue);
	}

	/**
	 * Remove an RID from all queues (e.g., if it was classified).
	 *
	 * @param rid Revision-ID whose row should be deleted (if present).
	 */
	public synchronized void queue_delete(long rid)
			throws Exception {
		cstmt_queue_delete.setLong(1, rid);
		cstmt_queue_delete.execute();
	}

	/**
	 * "Resurrect" an RID, placing a previously classified RID back in all
	 * queues, as may be required per use of the "back" button. If necessary,
	 * remove the [feedback] recorded at initial classification.
	 *
	 * @param rid Revision identififier of RID to be resurrected
	 * @param pid Page identififier of RID to be resurrected
	 */
	public synchronized void queue_resurrect(long rid, long pid)
			throws Exception {
		cstmt_queue_resurrect.setLong(1, rid);
		cstmt_queue_resurrect.setLong(2, pid);
		cstmt_queue_resurrect.execute();
	}

	/**
	 * Mark a particular edit as being 'ignored' by some user, making it such
	 * that they will not be presented the edit in again in the future. This
	 * should hold regardless of what edit queue they are using.
	 *
	 * @param rid  Revision-ID of revision being marked as ignored
	 * @param user User who should never again see revision 'rid'
	 */
	public synchronized void queue_ignore(long rid, String user)
			throws Exception {
		cstmt_queue_ignore.setLong(1, rid);
		cstmt_queue_ignore.setString(2, user);
		cstmt_queue_ignore.execute();
	}

	/**
	 * Release all edits in some reservation (which have not yet been
	 * classified), so that that they can be picked up by other clients.
	 *
	 * @param res_id Reservation ID of original reservation request
	 */
	public synchronized void queue_wipe(long res_id) throws Exception {
		cstmt_queue_wipe.setLong(1, res_id);
		cstmt_queue_wipe.execute();
	}

	/**
	 * Shutdown all objects created by this class (DB handlers).
	 */
	public void shutdown() throws Exception {
		cstmt_queue_delete.close();
		cstmt_queue_fetch_cbng.close();
		cstmt_queue_fetch_stiki.close();
		cstmt_queue_fetch_wt.close();
		cstmt_queue_fetch_spam.close();
		cstmt_queue_ignore.close();
		cstmt_queue_resurrect.close();
		cstmt_queue_wipe.close();
	}


	// *************************** PRIVATE METHODS ***************************

	/**
	 * Prepare the databse (stored procedure) calls to be used by this class.
	 */
	private void prep_statements() throws Exception {

		cstmt_queue_fetch_cbng = con_client.con.prepareCall(
				"{CALL client_queue_fetch_cbng(?,?,?)}"); // 2 IN, 1 OUT params
		cstmt_queue_fetch_cbng.registerOutParameter(3, java.sql.Types.VARCHAR);

		cstmt_queue_fetch_stiki = con_client.con.prepareCall(
				"{CALL client_queue_fetch_stiki(?,?,?)}"); // 2 IN, 1 OUT params
		cstmt_queue_fetch_stiki.registerOutParameter(3, java.sql.Types.VARCHAR);

		cstmt_queue_fetch_wt = con_client.con.prepareCall(
				"{CALL client_queue_fetch_wt(?,?,?)}"); // 2 IN, 1 OUT params
		cstmt_queue_fetch_wt.registerOutParameter(3, java.sql.Types.VARCHAR);

		cstmt_queue_fetch_spam = con_client.con.prepareCall(
				"{CALL client_queue_fetch_spam(?,?,?)}"); // 2 IN, 1 OUT params
		cstmt_queue_fetch_spam.registerOutParameter(3, java.sql.Types.VARCHAR);

		cstmt_queue_delete = con_client.con.prepareCall(
				"{CALL client_queue_delete(?)}"); // 1 IN param

		cstmt_queue_ignore = con_client.con.prepareCall(
				"{CALL client_queue_ignore(?,?)}"); // 2 IN params

		cstmt_queue_resurrect = con_client.con.prepareCall(
				"{CALL client_queue_resurrect(?,?)}"); // 2 IN params

		cstmt_queue_wipe = con_client.con.prepareCall(
				"{CALL client_queue_wipe(?)}"); // 1 IN param
	}

}
